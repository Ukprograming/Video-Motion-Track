<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>動画運動解析（ブラウザ/iOS対応・手動トラッキング）</title>
<link rel="icon" href="data:,">
<style>
  :root { --gap: 12px; --card: #111827; --ink: #e5e7eb; --muted:#9ca3af; --accent:#22c55e; --danger:#ef4444; --warn:#f59e0b; --sky:#38bdf8;}
  html,body{height:100%}
  body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; background:#0b1220; color:var(--ink);}
  .wrap{max-width:1200px; margin:0 auto; padding:16px;}
  h1{font-size:clamp(18px,3vw,28px); margin:0 0 8px;}
  p.sub{color:var(--muted); margin:0 0 16px}
  .grid{display:grid; grid-template-columns: 1.15fr 1fr; gap:var(--gap)}
  .card{background:var(--card); border:1px solid #1f2937; border-radius:14px; padding:12px;}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .row > *{margin:4px 0}
  label{font-size:12px; color:var(--muted)}
  input[type="number"], input[type="text"], input[type="file"], select, button{background:#0f172a; color:var(--ink); border:1px solid #374151; border-radius:10px; padding:8px 10px; font-size:14px}
  button{cursor:pointer}
  button.primary{background:#0b2b17; border-color:#134e32}
  button.accent{background:#0d2918; border-color:#14532d; color:#a7f3d0}
  button.warn{background:#2b1f0b; border-color:#78350f; color:#fde68a}
  button.danger{background:#2b0b0b; border-color:#7f1d1d; color:#fecaca}
  button:disabled{opacity:.5; cursor:not-allowed}
  .pill{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; background:#0f172a; border:1px solid #374151; font-size:12px; color:var(--muted)}
  canvas{width:100%; height:auto; background:#000; border-radius:12px; touch-action:none}
  .mini{font-size:12px; color:var(--muted)}
  .kpi{display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:10px; margin:8px 0 0}
  .kpi .card{padding:10px}
  .kpi .val{font-weight:700; font-size:18px}
  .sep{height:1px; background:#1f2937; margin:8px 0}
  .hint{color:#a5b4fc}
  table th, table td{border-bottom:1px solid #1f2937; padding:4px 6px; text-align:right}
  table th:first-child, table td:first-child{text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>動画運動解析アプリ</h1>
  <p class="sub"><br>・1 m 物体でスケール校正 → 軸の設定（任意）→ 1コマずつクリックで座標記録（最初の記録点を原点扱い） → グラフ自動更新 → 画像/CSV保存</p>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <label>動画を読み込む</label>
          <input id="file" type="file" accept="video/*" />
          <button id="btnDemo" class="warn" title="小さなデモ動画を読み込み">デモ</button>
        </div>
        <div class="pill" title="iOS向け設定: インライン再生・自動停止">
          <span>iOS最適化</span>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="btnPrev">◀︎ 1フレーム</button>
        <button id="btnNext">1フレーム ▶︎</button>
        <button id="btnPlay" class="primary">再生/一時停止</button>
        <div class="pill"><span>FPS</span> <input id="fps" type="number" step="0.01" value="30" style="width:78px"> <span class="mini">（自動取得が不安定な時は手入力）</span></div>
        <div class="pill"><label><input id="autoStep" type="checkbox" checked> クリック後に自動で1コマ進む</label></div>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="btnCalib" class="accent">1 m 校正（ドラッグ）</button>
        <span id="scaleInfo" class="mini">未校正</span>

        <!-- 初期は無効化（校正完了で有効化） -->
        <button id="btnAxis" class="accent" disabled>軸の設定</button>
        <button id="btnStartPlot" class="primary" disabled>プロットの開始</button>

        <span id="originInfo" class="mini">原点: 初期点</span>
        <button id="btnUndo" class="warn">一つ戻す</button>
        <button id="btnClear" class="danger">全消去</button>
      </div>

      <div class="sep"></div>

      <canvas id="canvas" width="960" height="540"></canvas>
      <div class="mini hint">
        操作ヒント：<b>校正</b>後、必要なら<b>軸の設定</b>でx軸・y軸をドラッグで移動／回転（原点ハンドル＝中心丸、角度ハンドル＝x軸上の丸）。<br>
        「プロットの開始」で通常どおりクリック記録（記録後は自動で1コマ進む）。
      </div>

      <video id="video" playsinline muted preload="metadata" style="display:none"></video>
    </div>

    <div class="card">
      <div class="kpi">
        <div class="card"><div class="mini">記録点数</div><div id="kPoints" class="val">0</div></div>
        <div class="card"><div class="mini">経過時間[s]</div><div id="kTime" class="val">0.000</div></div>
        <div class="card"><div class="mini">スケール[px/m]</div><div id="kScale" class="val">—</div></div>
        <div class="card"><div class="mini">FPS</div><div id="kFPS" class="val">30.00</div></div>
      </div>

      <div class="sep"></div>

      <div class="row">
        <button id="btnCSV" class="primary">CSVダウンロード</button>
        <button id="btnPNGCurrent" title="現在のグラフ画像">グラフ画像</button>
      </div>

      <details style="margin-top:8px"><summary>計算設定（微分法）</summary>
        <div class="row" style="margin-top:6px">
          <label>速度：中央差分</label>
          <label>加速度：中央差分</label>
          <label class="mini">端点は前進/後退差分</label>
        </div>
      </details>

      <div class="sep"></div>

      <div class="row" id="chartControls" style="margin-bottom:8px">
        <button class="modeBtn" data-mode="xt">x-t</button>
        <button class="modeBtn" data-mode="yt">y-t</button>
        <button class="modeBtn" data-mode="vxt">vx-t</button>
        <button class="modeBtn" data-mode="vyt">vy-t</button>
        <button class="modeBtn" data-mode="axt">ax-t</button>
        <button class="modeBtn" data-mode="ayt">ay-t</button>
        <span class="pill">現在: <span id="modeLabel">x-t</span></span>
      </div>
      <div id="rightPane" style="display:grid; grid-template-rows: 260px 1fr; gap:8px; height:420px">
        <div id="chartBox" style="height:260px; overflow:hidden">
          <canvas id="chart_main" style="width:100%; height:100%"></canvas>
        </div>
        <div class="card" style="overflow:auto;">
          <table id="dataTable" style="width:100%; border-collapse:collapse; font-size:12px">
            <thead>
              <tr>
                <th>#</th><th>t[s]</th><th>x[m]</th><th>y[m]</th><th>vx[m/s]</th><th>vy[m/s]</th><th>ax[m/s²]</th><th>ay[m/s²]</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
(() => {
  // ====== デモ動画の相対パス（方式A）======
  // リポジトリ内に /demo.mp4 を置いてください
  const DEMO_URL = "./demo.mp4";

  // DOM refs
  const file = document.getElementById('file');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnPlay = document.getElementById('btnPlay');
  const btnCalib = document.getElementById('btnCalib');
  const btnUndo = document.getElementById('btnUndo');
  const btnClear = document.getElementById('btnClear');
  const btnDemo = document.getElementById('btnDemo');
  const fpsInput = document.getElementById('fps');
  const autoStep = document.getElementById('autoStep');
  const scaleInfo = document.getElementById('scaleInfo');
  const originInfo = document.getElementById('originInfo');
  const kPoints = document.getElementById('kPoints');
  const kTime = document.getElementById('kTime');
  const kScale = document.getElementById('kScale');
  const kFPS = document.getElementById('kFPS');
  const btnCSV = document.getElementById('btnCSV');
  const btnAxis = document.getElementById('btnAxis');
  const btnStartPlot = document.getElementById('btnStartPlot');

  // State
  let points = []; // {t, xpx, ypx, xm, ym}
  let origin = null; // {xm, ym}
  let scalePxPerMeter = null; // pixels per meter
  let calibMode = false;
  let playing = false;

  // 校正ドラッグ用
  let calibStart = null, calibEnd = null, calibDragging = false;

  // 軸設定
  let axisMode = false;   // 軸を表示＆編集
  let axisActive = false; // 軸を確定してプロットに利用
  let axis = { ox: 480, oy: 270, theta: 0 }; // ピクセル座標の原点、ラジアン
  const AXIS_HANDLE_R = 10;
  const AXIS_HANDLE_LEN = 80; // x軸上の角度ハンドルまでの距離

  // Chart (single)
  const ch = new Chart(document.getElementById('chart_main'), {
    type: 'line',
    data: { labels: [], datasets: [{ label: '', data: [], pointRadius:2, tension:0 }]},
    options: {
      animation:false, responsive:true, maintainAspectRatio:false,
      scales: {
        x: { title: { display:true, text:'t [s]', color:'#e5e7eb' }, ticks: { color:'#e5e7eb' }, grid: { color:'#334155' } },
        y: { title: { display:true, text:'', color:'#e5e7eb' }, ticks: { color:'#e5e7eb' }, grid: { color:'#334155' } }
      },
      plugins: { legend:{display:false} }
    }
  });
  let mode='xt';

  // Helpers
  const dpr = () => (window.devicePixelRatio || 1);
  function resizeCanvasToVideo() {
    const w = video.videoWidth || 960;
    const h = video.videoHeight || 540;
    const ratio = dpr();
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    ctx.setTransform(ratio,0,0,ratio,0,0);
    axis.ox = w/2; axis.oy = h/2; // 軸の原点を中央へ
    drawFrame();
  }

  function drawInfiniteLine(point, dir, color, width=2) {
    const w = canvas.width / dpr(), h = canvas.height / dpr();
    const L = Math.max(w,h) * 2;
    ctx.save();
    ctx.strokeStyle = color; ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(point.x - dir.x * L, point.y - dir.y * L);
    ctx.lineTo(point.x + dir.x * L, point.y + dir.y * L);
    ctx.stroke();
    ctx.restore();
  }

  function drawAxisOverlay(){
    const ex = { x: Math.cos(axis.theta), y: Math.sin(axis.theta) };
    const ey = { x:  Math.sin(axis.theta), y: -Math.cos(axis.theta) };

    drawInfiniteLine({x:axis.ox, y:axis.oy}, ex, '#22c55e');  // x軸: 緑
    drawInfiniteLine({x:axis.ox, y:axis.oy}, ey, '#60a5fa');  // y軸: 青

    ctx.fillStyle = '#f8fafc';
    ctx.beginPath(); ctx.arc(axis.ox, axis.oy, AXIS_HANDLE_R, 0, Math.PI*2); ctx.fill();

    const hx = axis.ox + ex.x * AXIS_HANDLE_LEN;
    const hy = axis.oy + ex.y * AXIS_HANDLE_LEN;
    ctx.fillStyle = '#facc15';
    ctx.beginPath(); ctx.arc(hx, hy, AXIS_HANDLE_R, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#22c55e'; ctx.font = '14px system-ui';
    ctx.fillText('x', axis.ox + ex.x * (AXIS_HANDLE_LEN + 14), axis.oy + ex.y * (AXIS_HANDLE_LEN + 14));
    ctx.fillStyle = '#60a5fa';
    ctx.fillText('y', axis.ox + ey.x * (AXIS_HANDLE_LEN + 14), axis.oy + ey.y * (AXIS_HANDLE_LEN + 14));
  }

  function drawFrame() {
    const w = canvas.width / dpr();
    const h = canvas.height / dpr();
    ctx.clearRect(0,0,w,h);
    if (!isNaN(video.duration) && video.readyState >= 2) {
      try { ctx.drawImage(video, 0, 0, w, h); } catch(e) {}
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
    }

    if (calibMode) {
      if (calibDragging && calibStart) {
        const a = calibStart, b = (calibEnd || mousePos);
        ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        const d = Math.hypot(b.x - a.x, b.y - a.y);
        ctx.fillStyle = '#fde68a'; ctx.font = '12px system-ui';
        ctx.fillText(`${d.toFixed(1)} px`, (a.x+b.x)/2 + 6, (a.y+b.y)/2 - 6);
      }
    }

    if (axisMode) drawAxisOverlay();

    if (points.length) {
      ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2; ctx.beginPath();
      ctx.moveTo(points[0].xpx, points[0].ypx);
      for (let i=1;i<points.length;i++){ ctx.lineTo(points[i].xpx, points[i].ypx); }
      ctx.stroke();
      for (let i=0;i<points.length;i++){
        ctx.fillStyle = '#22c55e';
        ctx.beginPath(); ctx.arc(points[i].xpx, points[i].ypx, 4, 0, Math.PI*2); ctx.fill();
      }
    }

    if (mousePos){
      ctx.strokeStyle = '#9ca3afaa'; ctx.lineWidth = 1; ctx.beginPath();
      ctx.moveTo(mousePos.x-10, mousePos.y); ctx.lineTo(mousePos.x+10, mousePos.y);
      ctx.moveTo(mousePos.x, mousePos.y-10); ctx.lineTo(mousePos.x, mousePos.y+10);
      ctx.stroke();
    }
  }

  // Pointer
  const rect = () => canvas.getBoundingClientRect();
  let mousePos = {x:0,y:0};
  function getXY(evt){
    const r = rect();
    const ratio = canvas.width / dpr() / r.width;
    return { x: (evt.clientX - r.left) * ratio, y: (evt.clientY - r.top) * ratio };
  }

  // 軸ドラッグ判定
  let dragMode = null; // 'moveOrigin' | 'rotate' | null
  function hitCircle(px,py,cx,cy,r){ return Math.hypot(px-cx, py-cy) <= r; }

  canvas.addEventListener('pointermove', e => {
    mousePos = getXY(e);
    if (calibMode && calibDragging) { calibEnd = getXY(e); }
    if (axisMode && dragMode){
      if (dragMode==='moveOrigin'){ axis.ox = mousePos.x; axis.oy = mousePos.y; }
      else if (dragMode==='rotate'){ axis.theta = Math.atan2(mousePos.y - axis.oy, mousePos.x - axis.ox); }
    }
    drawFrame();
  }, {passive:false});

  canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const p = getXY(e);

    if (axisMode){
      const ex = { x: Math.cos(axis.theta), y: Math.sin(axis.theta) };
      const hx = axis.ox + ex.x * AXIS_HANDLE_LEN;
      const hy = axis.oy + ex.y * AXIS_HANDLE_LEN;
      if (hitCircle(p.x,p.y, axis.ox,axis.oy, AXIS_HANDLE_R*1.5))      dragMode = 'moveOrigin';
      else if (hitCircle(p.x,p.y, hx,hy, AXIS_HANDLE_R*1.5))           dragMode = 'rotate';
      else dragMode = null;
      return;
    }

    if (calibMode){
      calibStart = p; calibEnd = p; calibDragging = true;
      drawFrame(); return;
    }

    recordPoint(p.x, p.y, video.currentTime);
    if (autoStep.checked) stepFrame(+1);
  }, {passive:false});

  canvas.addEventListener('pointerup', e => {
    if (calibMode && calibDragging && calibStart) {
      calibEnd = getXY(e);
      finalizeCalibration(calibStart, calibEnd);
    }
    dragMode = null;
  }, {passive:false});

  // 校正確定
  function finalizeCalibration(a, b){
    const dpx = Math.hypot(b.x - a.x, b.y - a.y);
    if (dpx > 0) {
      scalePxPerMeter = dpx / 1.0; // 1mのpx
      scaleInfo.textContent = `校正済: ${dpx.toFixed(1)} px = 1.000 m`;
      kScale.textContent = scalePxPerMeter.toFixed(2);
      // 校正が済むまで無効だった「軸の設定」を有効化
      btnAxis.disabled = false;
    }
    calibMode = false; calibDragging = false; calibStart = calibEnd = null;
    btnCalib.disabled = false;
    drawFrame();
  }

  // 座標変換（軸）
  function pxToAxisMeters(xpx, ypx){
    if (!scalePxPerMeter) return {xm:NaN, ym:NaN};
    const vx = xpx - axis.ox, vy = ypx - axis.oy;
    const c = Math.cos(axis.theta), s = Math.sin(axis.theta);
    const xr_px =  vx*c + vy*s;        // ex = (c,s)
    const yr_px =  vx*s + vy*(-c);     // ey = ( s,-c ) 上向き正
    return { xm: xr_px/scalePxPerMeter, ym: yr_px/scalePxPerMeter };
  }

  function recordPoint(xpx, ypx, t){
    if (scalePxPerMeter==null){ alert('先に「1 m 校正」を行ってください。'); return; }
    if (axisActive!==true){ axis.theta = axis.theta || 0; }
    const loc = pxToAxisMeters(xpx, ypx);
    if (points.length === 0 && !origin) {
      origin = { xm: loc.xm, ym: loc.ym };
      originInfo.textContent = `原点: 初期点`;
    }
    const xm = loc.xm - (origin?.xm ?? 0);
    const ym = loc.ym - (origin?.ym ?? 0);

    points.push({t, xpx, ypx, xm, ym});
    points.sort((a,b) => a.t - b.t);
    kPoints.textContent = points.length;
    if (points.length > 1) kTime.textContent = (points[points.length-1].t - points[0].t).toFixed(3);
    recompute();
    drawFrame();
  }

  function recompute(){
    if (points.length === 0) { renderTable([],[],[],[],[],[],[]); updateMainChart([],[],[],[],[],[],[]); return; }
    const t = points.map(p=>p.t);
    const x = points.map(p=>p.xm);
    const y = points.map(p=>p.ym);
    const vx = diffCentral(t,x);
    const vy = diffCentral(t,y);
    const ax = diffCentral(t,vx);
    const ay = diffCentral(t,vy);
    renderTable(t,x,y,vx,vy,ax,ay);
    updateMainChart(t,x,y,vx,vy,ax,ay);
  }

  function updateMainChart(t,x,y,vx,vy,ax,ay){
    let data=[], ylabel='';
    switch(mode){
      case 'xt': data=x; ylabel='x [m]'; break;
      case 'yt': data=y; ylabel='y [m]'; break;
      case 'vxt': data=vx; ylabel='vx [m/s]'; break;
      case 'vyt': data=vy; ylabel='vy [m/s]'; break;
      case 'axt': data=ax; ylabel='ax [m/s²]'; break;
      case 'ayt': data=ay; ylabel='ay [m/s²]'; break;
    }
    ch.data.labels = t.map(s=>(+s).toFixed(3));
    ch.data.datasets[0].label = mode.toUpperCase();
    ch.options.scales.y.title.text = ylabel;
    ch.data.datasets[0].data = data;

    if (Array.isArray(data) && data.length){
      let dmin = Infinity, dmax = -Infinity;
      for (const v of data){ if (Number.isFinite(v)){ dmin = Math.min(dmin,v); dmax = Math.max(dmax,v); } }
      if (!Number.isFinite(dmin) || !Number.isFinite(dmax)) { dmin=-1; dmax=1; }
      let lo = Math.min(0, dmin), hi = Math.max(0, dmax);
      if (hi === lo){ const pad = (Math.abs(hi)||1)*0.5; lo -= pad; hi += pad; }
      else { const pad = (hi - lo) * 0.05; lo -= pad; hi += pad; }
      ch.options.scales.y.min = lo; ch.options.scales.y.max = hi;
    } else { ch.options.scales.y.min = -1; ch.options.scales.y.max = 1; }

    ch.update();
    const ml = document.getElementById('modeLabel');
    if(ml) ml.textContent = ({xt:'x-t',yt:'y-t',vxt:'vx-t',vyt:'vy-t',axt:'ax-t',ayt:'ay-t'})[mode] || mode;
  }

  function diffCentral(t, y){
    if (t.length<2) return t.map(()=>NaN);
    const n=t.length; const dy = new Array(n).fill(NaN);
    if (n > 1) { dy[0] = (y[1]-y[0])/(t[1]-t[0]); dy[n-1] = (y[n-1]-y[n-2])/(t[n-1]-t[n-2]); }
    for (let i=1;i<n-1;i++){ const dt = t[i+1]-t[i-1]; if (Math.abs(dt) > 1e-9) dy[i] = (y[i+1]-y[i-1]) / dt; }
    return dy;
  }

  // Video control
  function stepFrame(dir){
    const fps = clampFPS(+fpsInput.value);
    kFPS.textContent = fps.toFixed(2);
    const dt = 1.0/Math.max(1, fps);
    video.pause(); playing=false; btnPlay.textContent = '再生/一時停止';
    const target = clamp(video.currentTime + dir*dt, 0, (video.duration||0));
    return seekTo(target);
  }
  function clamp(v,min=0,max=1){ return Math.min(max, Math.max(min, v)); }
  function clampFPS(v){ if (!isFinite(v) || v<=0) return 30; return Math.min(240, Math.max(1, v)); }
  function seekTo(t){
    return new Promise(res=>{
      const on = ()=>{ video.removeEventListener('seeked', on); drawFrame(); res(); };
      video.addEventListener('seeked', on, {once:true});
      video.currentTime = t;
    });
  }

  btnPrev.onclick = ()=> stepFrame(-1);
  btnNext.onclick = ()=> stepFrame(+1);
  btnPlay.onclick = ()=>{ if (!playing){ video.play(); playing=true; btnPlay.textContent='一時停止'; } else { video.pause(); playing=false; btnPlay.textContent='再生/一時停止'; } };

  // 1m校正
  btnCalib.onclick = ()=>{
    calibMode = true; calibDragging = false; calibStart = calibEnd = null;
    btnCalib.disabled = true; scaleInfo.textContent='1 m の両端をドラッグして指定';
  };

  // 軸の設定 → プロット開始
  btnAxis.onclick = ()=>{
    axisMode = true; axisActive = false;
    btnStartPlot.disabled = false;
    drawFrame();
  };
  btnStartPlot.onclick = ()=>{
    axisMode = false; axisActive = true;
    btnStartPlot.disabled = true;
    drawFrame();
  };

  // 一つ戻す（動画も1コマ戻す）
  btnUndo.onclick = async ()=>{
    if(points.length){
      points.pop();
      kPoints.textContent = points.length;
      recompute();
      await stepFrame(-1);
    }
  };

  btnClear.onclick = ()=>{
    if(confirm('記録をすべて消去しますか？')){
      points=[]; origin=null; calibMode=false; calibDragging=false; calibStart=calibEnd=null;
      axisActive=false; axisMode=false;
      btnAxis.disabled = true;       // ← 校正が済むまで無効
      btnStartPlot.disabled = true;

      kPoints.textContent='0'; kTime.textContent='0.000'; originInfo.textContent='原点: 初期点';
      scaleInfo.textContent='未校正'; kScale.textContent='—';
      drawFrame(); recompute();
    }
  };

  // ファイル読込
  file.addEventListener('change', async (e)=>{
    if (!e.target.files || !e.target.files[0]) return;
    const f = e.target.files[0];
    await loadVideo(URL.createObjectURL(f));
  });

  // ★デモ動画（方式A：相対パス）
  btnDemo.onclick = async ()=>{
    try {
      await loadVideo(DEMO_URL);
    } catch (e) {
      console.error(e);
      alert("デモ動画の読み込みに失敗しました。/demo.mp4 の配置を確認してください。");
    }
  };

  async function loadVideo(url){
    resetAll();
    video.src = url;
    video.playsInline = true; // iOS
    video.muted = true;
    await video.load();
    await new Promise(res=> video.addEventListener('loadedmetadata', res, {once:true}));
    guessFPS();
    resizeCanvasToVideo();
    drawFrame();
  }

  function resetAll(){
    points=[]; origin=null; scalePxPerMeter=null; calibMode=false; calibDragging=false; calibStart=calibEnd=null;
    axisActive=false; axisMode=false; 
    axis.theta=0; // 原点はresize時に中央へ
    // 校正が済むまで軸の設定は無効
    btnAxis.disabled = true;
    btnStartPlot.disabled = true;

    kPoints.textContent='0'; kTime.textContent='0.000'; kScale.textContent='—'; scaleInfo.textContent='未校正'; originInfo.textContent='原点: 初期点';
    ch.data.labels=[]; ch.data.datasets[0].data=[]; ch.update();
    recompute();
  }

  function guessFPS(){
    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype){
      try {
        let t0=null, t1=null;
        const cb = (_, info)=>{
          if (!t0){ t0 = info.mediaTime; video.requestVideoFrameCallback(cb); }
          else if (!t1){ t1 = info.mediaTime; const fps = 1/Math.max(1e-6, (t1-t0)); if (fps>5 && fps<240){ fpsInput.value = fps.toFixed(2); kFPS.textContent=fps.toFixed(2);} }
        };
        video.requestVideoFrameCallback(cb);
      } catch(e){}
    }
  }

  function renderTable(t,x,y,vx,vy,ax,ay){
    const tb = document.getElementById('tableBody'); if(!tb) return;
    let html='';
    for(let i=0;i<points.length;i++){
      html += `<tr><td>${i}</td><td>${(t[i]??NaN).toFixed(3)}</td><td>${(x[i]??NaN).toFixed(4)}</td><td>${(y[i]??NaN).toFixed(4)}</td><td>${(vx[i]??NaN).toFixed(4)}</td><td>${(vy[i]??NaN).toFixed(4)}</td><td>${(ax[i]??NaN).toFixed(4)}</td><td>${(ay[i]??NaN).toFixed(4)}</td></tr>`;
    }
    tb.innerHTML = html;
  }

  // CSV & PNG
  function download(name, blob){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name; a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  }

  btnCSV.onclick = ()=>{
    if (points.length === 0) { alert("記録されたデータがありません。"); return; }
    const t = points.map(p=>p.t);
    const x = points.map(p=>p.xm);
    const y = points.map(p=>p.ym);
    const vx = diffCentral(t,x);
    const vy = diffCentral(t,y);
    const ax = diffCentral(t,vx);
    const ay = diffCentral(t,vy);
    const header = ['frame','t_s','x_px','y_px','x_m','y_m','vx_m_s','vy_m_s','ax_m_s2','ay_m_s2'];
    const rows = [header.join(',')];
    for (let i=0;i<points.length;i++){
      const row = [i, t[i]?.toFixed(6), points[i].xpx.toFixed(2), points[i].ypx.toFixed(2), x[i]?.toFixed(6), y[i]?.toFixed(6), (vx[i]??NaN).toFixed(6), (vy[i]??NaN).toFixed(6), (ax[i]??NaN).toFixed(6), (ay[i]??NaN).toFixed(6)];
      rows.push(row.join(','));
    }
    const csv = rows.join('\n');
    download('motion_data.csv', new Blob([csv], {type:'text/csv'}));
  };

  const btnPNGCurrent = document.getElementById('btnPNGCurrent');
  if(btnPNGCurrent){
    btnPNGCurrent.onclick = ()=>{
      const url = ch.toBase64Image();
      fetch(url).then(res=>res.blob()).then(b=> download(`graph_${mode}.png`, b));
    };
  }

  // グラフモード切り替え
  document.querySelectorAll('.modeBtn').forEach(btn => {
    btn.addEventListener('click', () => { mode = btn.dataset.mode; recompute(); });
  });

  // Rendering loop while playing
  function raf(){ if (playing) drawFrame(); requestAnimationFrame(raf); }
  raf();

  // Redraw on timeupdate & resize
  video.addEventListener('timeupdate', drawFrame);
  window.addEventListener('resize', ()=>{ if (video.videoWidth) resizeCanvasToVideo(); });
})();
</script>
</body>
</html>

