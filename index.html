<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>動画運動解析</title>
    <link rel="icon" href="data:,">
    <style>
        :root {
            --gap: 12px;
            --card: #111827;
            --ink: #e5e7eb;
            --muted: #9ca3af;
            --accent: #22c55e;
            --danger: #ef4444;
            --warn: #f59e0b;
            --sky: #38bdf8;
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background: #0b1220;
            color: var(--ink);
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
        }

        h1 {
            font-size: clamp(18px, 3vw, 28px);
            margin: 0 0 8px;
        }

        p.sub {
            color: var(--muted);
            margin: 0 0 16px
        }

        .grid {
            display: grid;
            grid-template-columns: 1.15fr 1fr;
            gap: var(--gap)
        }

        .card {
            background: var(--card);
            border: 1px solid #1f2937;
            border-radius: 14px;
            padding: 12px;
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center
        }

        .row>* {
            margin: 4px 0
        }

        label {
            font-size: 12px;
            color: var(--muted)
        }

        input[type="number"],
        input[type="text"],
        input[type="file"],
        select,
        button {
            background: #0f172a;
            color: var(--ink);
            border: 1px solid #374151;
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 14px
        }

        button {
            cursor: pointer
        }

        button.primary {
            background: #0b2b17;
            border-color: #134e32
        }

        button.accent {
            background: #0d2918;
            border-color: #14532d;
            color: #a7f3d0
        }

        button.warn {
            background: #2b1f0b;
            border-color: #78350f;
            color: #fde68a
        }

        button.danger {
            background: #2b0b0b;
            border-color: #7f1d1d;
            color: #fecaca
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        .pill {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            background: #0f172a;
            border: 1px solid #374151;
            font-size: 12px;
            color: var(--muted)
        }

        canvas {
            width: 100%;
            height: auto;
            background: #000;
            border-radius: 12px;
            touch-action: none
        }

        .mini {
            font-size: 12px;
            color: var(--muted)
        }

        .kpi {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
            margin: 8px 0 0
        }

        .kpi .card {
            padding: 10px
        }

        .kpi .val {
            font-weight: 700;
            font-size: 18px
        }

        .sep {
            height: 1px;
            background: #1f2937;
            margin: 8px 0
        }

        .hint {
            color: #a5b4fc
        }

        table th,
        table td {
            border-bottom: 1px solid #1f2937;
            padding: 4px 6px;
            text-align: right
        }

        table th:first-child,
        table td:first-child {
            text-align: center
        }

        /* グラフ上のカーソル（縦線） */
        #time-cursor {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: rgba(255, 0, 0, 0.8);
            /* 赤色、少し透明 */
            pointer-events: none;
            /* マウス操作を邪魔しない */
            display: none;
            /* 最初は非表示 */
            z-index: 10;
            transition: left 0.05s linear;
            /* 滑らかに動かす */
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>動画運動解析アプリ <span class="mini" style="font-weight:normal"></span></h1>
        <p class="sub"><br>・1 m 物体でスケール校正 → 軸の設定（任意）→ 1コマずつクリックで座標記録（最初の記録点を原点扱い） → グラフ自動更新 → 画像/CSV保存</p>

        <div class="grid">
            <div class="card">
                <div class="row" style="justify-content:space-between">
                    <div class="row">
                        <label>動画を読み込む</label>
                        <input id="file" type="file" accept="video/*" />
                        <button id="btnDemo" class="warn" title="小さなデモ動画を読み込み">デモ</button>
                    </div>
                    <div class="pill" title="iOS向け設定: インライン再生・自動停止">
                        <span>iOS最適化</span>
                    </div>
                </div>

                <div class="row" style="margin-top:6px">
                    <button id="btnPrev">◀︎ 1フレーム</button>
                    <button id="btnNext">1フレーム ▶︎</button>
                    <button id="btnPlay" class="primary">再生/一時停止</button>
                    <div class="pill"><span>FPS</span> <input id="fps" type="number" step="0.01" value="30"
                            style="width:78px"> <span class="mini">（自動取得が不安定な時は手入力）</span></div>
                    <div class="pill"><label><input id="autoStep" type="checkbox" checked> クリック後に自動で1コマ進む</label></div>
                </div>

                <div class="row" style="margin-top:6px">
                    <button id="btnCalib" class="accent">1 m 校正（ドラッグ）</button>
                    <span id="scaleInfo" class="mini">未校正</span>

                    <button id="btnAxis" class="accent" disabled>軸の設定</button>
                    <button id="btnStartPlot" class="primary" disabled>プロットの開始</button>

                    <span id="originInfo" class="mini">原点: 初期点</span>
                    <button id="btnUndo" class="warn">一つ戻す</button>
                    <button id="btnClear" class="danger">全消去</button>
                </div>

                <div class="sep"></div>

                <canvas id="canvas" width="960" height="540"></canvas>
                <div class="mini hint">
                    操作ヒント：<b>校正</b>後、必要なら<b>軸の設定</b>でx軸・y軸をドラッグで移動／回転（原点ハンドル＝中心丸、角度ハンドル＝x軸上の丸）。<br>
                    「プロットの開始」で通常どおりクリック記録（記録後は自動で1コマ進む）。
                </div>

                <video id="video" playsinline muted preload="metadata" style="display:none"></video>
            </div>

            <div class="card">
                <div class="kpi">
                    <div class="card">
                        <div class="mini">記録点数</div>
                        <div id="kPoints" class="val">0</div>
                    </div>
                    <div class="card">
                        <div class="mini">経過時間[s]</div>
                        <div id="kTime" class="val">0.000</div>
                    </div>
                    <div class="card">
                        <div class="mini">スケール[px/m]</div>
                        <div id="kScale" class="val">—</div>
                    </div>
                    <div class="card">
                        <div class="mini">FPS</div>
                        <div id="kFPS" class="val">30.00</div>
                    </div>
                </div>

                <div class="sep"></div>

                <div class="row">
                    <button id="btnCSV" class="primary">CSVダウンロード</button>
                    <button id="btnPNGCurrent" title="現在のグラフ画像">グラフ画像</button>
                </div>

                <details style="margin-top:8px">
                    <summary>計算設定（微分法）</summary>
                    <div class="row" style="margin-top:6px">
                        <label>速度：中央差分</label>
                        <label>加速度：中央差分</label>
                        <label class="mini">端点は前進/後退差分</label>
                    </div>
                </details>

                <div class="sep"></div>

                <div class="row" id="chartControls" style="margin-bottom:8px">
                    <button class="modeBtn" data-mode="xt">x-t</button>
                    <button class="modeBtn" data-mode="yt">y-t</button>
                    <button class="modeBtn" data-mode="vxt">vx-t</button>
                    <button class="modeBtn" data-mode="vyt">vy-t</button>
                    <button class="modeBtn" data-mode="axt">ax-t</button>
                    <button class="modeBtn" data-mode="ayt">ay-t</button>
                    <span class="pill">現在: <span id="modeLabel">x-t</span></span>
                </div>
                <div id="rightPane" style="display:grid; grid-template-rows: 260px 1fr; gap:8px; height:420px">
                    <div id="chartBox" style="height:260px; overflow:hidden; position: relative;">
                        <canvas id="chart_main" style="width:100%; height:100%"></canvas>
                        <div id="time-cursor"></div>
                    </div>
                    <div class="card" style="overflow:auto;">
                        <table id="dataTable" style="width:100%; border-collapse:collapse; font-size:12px">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>t[s]</th>
                                    <th>x[m]</th>
                                    <th>y[m]</th>
                                    <th>vx[m/s]</th>
                                    <th>vy[m/s]</th>
                                    <th>ax[m/s²]</th>
                                    <th>ay[m/s²]</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        (() => {
            // ====== デモ動画の相対パス（方式A）======
            const DEMO_URL = "./demo_faststart.mp4";

            // DOM refs
            const file = document.getElementById('file');
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const btnPrev = document.getElementById('btnPrev');
            const btnNext = document.getElementById('btnNext');
            const btnPlay = document.getElementById('btnPlay');
            const btnCalib = document.getElementById('btnCalib');
            const btnUndo = document.getElementById('btnUndo');
            const btnClear = document.getElementById('btnClear');
            const btnDemo = document.getElementById('btnDemo');
            const fpsInput = document.getElementById('fps');
            const autoStep = document.getElementById('autoStep');
            const scaleInfo = document.getElementById('scaleInfo');
            const originInfo = document.getElementById('originInfo');
            const kPoints = document.getElementById('kPoints');
            const kTime = document.getElementById('kTime');
            const kScale = document.getElementById('kScale');
            const kFPS = document.getElementById('kFPS');
            const btnCSV = document.getElementById('btnCSV');
            const btnPNGCurrent = document.getElementById('btnPNGCurrent');
            const btnAxis = document.getElementById('btnAxis');
            const btnStartPlot = document.getElementById('btnStartPlot');
            const modeButtons = document.querySelectorAll('.modeBtn');

            // State
            let points = []; // {t, xpx, ypx, xm, ym}
            let origin = null; // {xm, ym}
            let scalePxPerMeter = null; // pixels per meter
            let calibMode = false;
            let playing = false;

            // 校正ドラッグ用
            let calibStart = null, calibEnd = null, calibDragging = false;

            // 軸設定
            let axisMode = false;   // 軸を表示＆編集
            let axisActive = false; // 軸を確定してプロットに利用
            let axis = { ox: 480, oy: 270, theta: 0 }; // ピクセル座標の原点、ラジアン
            const AXIS_HANDLE_R = 10;
            const AXIS_HANDLE_LEN = 80; // x軸上の角度ハンドルまでの距離

            // Chart (single)
            const ch = new Chart(document.getElementById('chart_main'), {
                type: 'line',
                data: { labels: [], datasets: [{ label: '', data: [], pointRadius: 2, tension: 0, borderColor: '#38bdf8', backgroundColor: '#38bdf8' }] },
                options: {
                    animation: false, responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear', // ★ここが重要：時間を数値として扱う
                            min: 0,         // 常に0秒から開始
                            title: { display: true, text: 't [s]', color: '#e5e7eb' },
                            ticks: { color: '#e5e7eb' },
                            grid: { color: '#334155' }
                        },
                        y: { title: { display: true, text: '', color: '#e5e7eb' }, ticks: { color: '#e5e7eb' }, grid: { color: '#334155' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
            let mode = 'xt';

            // Helpers
            const dpr = () => (window.devicePixelRatio || 1);
            function resizeCanvasToVideo() {
                const w = video.videoWidth || 960;
                const h = video.videoHeight || 540;
                const ratio = dpr();
                canvas.width = w * ratio;
                canvas.height = h * ratio;
                ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
                axis.ox = w / 2; axis.oy = h / 2; // 軸の原点を中央へ
                drawFrame();
            }

            function drawInfiniteLine(point, dir, color, width = 2) {
                const w = canvas.width / dpr(), h = canvas.height / dpr();
                const L = Math.max(w, h) * 2;
                ctx.save();
                ctx.strokeStyle = color; ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(point.x - dir.x * L, point.y - dir.y * L);
                ctx.lineTo(point.x + dir.x * L, point.y + dir.y * L);
                ctx.stroke();
                ctx.restore();
            }

            function drawAxisOverlay() {
                const ex = { x: Math.cos(axis.theta), y: Math.sin(axis.theta) };
                const ey = { x: Math.sin(axis.theta), y: -Math.cos(axis.theta) };

                drawInfiniteLine({ x: axis.ox, y: axis.oy }, ex, '#22c55e');  // x軸: 緑
                drawInfiniteLine({ x: axis.ox, y: axis.oy }, ey, '#60a5fa');  // y軸: 青

                ctx.fillStyle = '#f8fafc';
                ctx.beginPath(); ctx.arc(axis.ox, axis.oy, AXIS_HANDLE_R, 0, Math.PI * 2); ctx.fill();

                const hx = axis.ox + ex.x * AXIS_HANDLE_LEN;
                const hy = axis.oy + ex.y * AXIS_HANDLE_LEN;
                ctx.fillStyle = '#facc15';
                ctx.beginPath(); ctx.arc(hx, hy, AXIS_HANDLE_R, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#22c55e'; ctx.font = '14px system-ui';
                ctx.fillText('x', axis.ox + ex.x * (AXIS_HANDLE_LEN + 14), axis.oy + ex.y * (AXIS_HANDLE_LEN + 14));
                ctx.fillStyle = '#60a5fa';
                ctx.fillText('y', axis.ox + ey.x * (AXIS_HANDLE_LEN + 14), axis.oy + ey.y * (AXIS_HANDLE_LEN + 14));
            }

            function drawFrame() {
                const w = canvas.width / dpr();
                const h = canvas.height / dpr();

                if (isNaN(video.duration)) {
                    return;
                }

                ctx.clearRect(0, 0, w, h); // ★修正: 描画できるとわかってから消す
                try { ctx.drawImage(video, 0, 0, w, h); } catch (e) { }

                if (calibMode) {
                    if (calibDragging && calibStart) {
                        const a = calibStart, b = (calibEnd || mousePos);
                        ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
                        const d = Math.hypot(b.x - a.x, b.y - a.y);
                        ctx.fillStyle = '#fde68a'; ctx.font = '12px system-ui';
                        ctx.fillText(`${d.toFixed(1)} px`, (a.x + b.x) / 2 + 6, (a.y + b.y) / 2 - 6);
                    }
                }

                if (axisMode) drawAxisOverlay();

                if (points.length) {
                    ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.moveTo(points[0].xpx, points[0].ypx);
                    for (let i = 1; i < points.length; i++) { ctx.lineTo(points[i].xpx, points[i].ypx); }
                    ctx.stroke();
                    for (let i = 0; i < points.length; i++) {
                        ctx.fillStyle = '#22c55e';
                        ctx.beginPath(); ctx.arc(points[i].xpx, points[i].ypx, 4, 0, Math.PI * 2); ctx.fill();
                    }
                }

                if (mousePos) {
                    ctx.strokeStyle = '#9ca3afaa'; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.moveTo(mousePos.x - 10, mousePos.y); ctx.lineTo(mousePos.x + 10, mousePos.y);
                    ctx.moveTo(mousePos.x, mousePos.y - 10); ctx.lineTo(mousePos.x, mousePos.y + 10);
                    ctx.stroke();
                }
            }

            // Pointer
            const rect = () => canvas.getBoundingClientRect();
            let mousePos = { x: 0, y: 0 };
            function getXY(evt) {
                const r = rect();
                const ratio = canvas.width / dpr() / r.width;
                return { x: (evt.clientX - r.left) * ratio, y: (evt.clientY - r.top) * ratio };
            }

            // 軸ドラッグ判定
            let dragMode = null; // 'moveOrigin' | 'rotate' | null
            function hitCircle(px, py, cx, cy, r) { return Math.hypot(px - cx, py - cy) <= r; }

            canvas.addEventListener('pointermove', e => {
                mousePos = getXY(e);
                if (calibMode && calibDragging) { calibEnd = getXY(e); }
                if (axisMode && dragMode) {
                    if (dragMode === 'moveOrigin') { axis.ox = mousePos.x; axis.oy = mousePos.y; }
                    else if (dragMode === 'rotate') { axis.theta = Math.atan2(mousePos.y - axis.oy, mousePos.x - axis.ox); }
                }
                drawFrame();
            }, { passive: false });

            canvas.addEventListener('pointerdown', async e => {
                e.preventDefault();
                if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
                const p = getXY(e);

                if (axisMode) {
                    const ex = { x: Math.cos(axis.theta), y: Math.sin(axis.theta) };
                    const hx = axis.ox + ex.x * AXIS_HANDLE_LEN;
                    const hy = axis.oy + ex.y * AXIS_HANDLE_LEN;
                    if (hitCircle(p.x, p.y, axis.ox, axis.oy, AXIS_HANDLE_R * 1.5)) dragMode = 'moveOrigin';
                    else if (hitCircle(p.x, p.y, hx, hy, AXIS_HANDLE_R * 1.5)) dragMode = 'rotate';
                    else dragMode = null;
                    return;
                }

                if (calibMode) {
                    calibStart = p; calibEnd = p; calibDragging = true;
                    drawFrame(); return;
                }

                // プロットは "プロット開始" が押されてから
                if (btnStartPlot.disabled && !axisActive) {
                    // 校正がまだ
                    if (scalePxPerMeter == null) alert('先に「1 m 校正」を行ってください。');
                    else alert('「プロットの開始」ボタンを押してから記録してください。');
                    return;
                }

                recordPoint(p.x, p.y, video.currentTime);
                if (autoStep.checked) await stepFrame(+1);
            }, { passive: false });

            canvas.addEventListener('pointerup', e => {
                if (canvas.releasePointerCapture) {
                    try { canvas.releasePointerCapture(e.pointerId); } catch (_) { }
                }
                if (calibMode && calibDragging && calibStart) {
                    calibEnd = getXY(e);
                    finalizeCalibration(calibStart, calibEnd);
                }
                dragMode = null;
            }, { passive: false });

            // 校正確定
            function finalizeCalibration(a, b) {
                const dpx = Math.hypot(b.x - a.x, b.y - a.y);
                if (dpx > 0) {
                    scalePxPerMeter = dpx / 1.0; // 1mのpx
                    scaleInfo.textContent = `校正済: ${dpx.toFixed(1)} px = 1.000 m`;
                    kScale.textContent = scalePxPerMeter.toFixed(2);
                    // 校正が済むまで無効だった「軸の設定」を有効化
                    btnAxis.disabled = false;
                }
                calibMode = false; calibDragging = false; calibStart = calibEnd = null;
                btnCalib.disabled = false;
                drawFrame();
            }

            // 座標変換（軸）
            function pxToAxisMeters(xpx, ypx) {
                if (!scalePxPerMeter) return { xm: NaN, ym: NaN };
                const vx = xpx - axis.ox, vy = ypx - axis.oy;
                const c = Math.cos(axis.theta), s = Math.sin(axis.theta);
                const xr_px = vx * c + vy * s;        // ex = (c,s)
                const yr_px = vx * s + vy * (-c);     // ey = ( s,-c ) 上向き正
                return { xm: xr_px / scalePxPerMeter, ym: yr_px / scalePxPerMeter };
            }

            function recordPoint(xpx, ypx, t) {
                if (scalePxPerMeter == null) { alert('先に「1 m 校正」を行ってください。'); return; }
                if (axisActive !== true) { axis.theta = axis.theta || 0; }
                const loc = pxToAxisMeters(xpx, ypx);
                if (points.length === 0 && !origin) {
                    origin = { xm: loc.xm, ym: loc.ym };
                    originInfo.textContent = `原点: 初期点`;
                }
                const xm = loc.xm - (origin?.xm ?? 0);
                const ym = loc.ym - (origin?.ym ?? 0);

                points.push({ t, xpx, ypx, xm, ym });
                points.sort((a, b) => a.t - b.t);
                kPoints.textContent = points.length;
                if (points.length > 1) kTime.textContent = (points[points.length - 1].t - points[0].t).toFixed(3);
                recompute();
                drawFrame();
            }

            function recompute() {
                if (points.length === 0) { renderTable([], [], [], [], [], [], []); updateMainChart([], [], [], [], [], [], []); return; }
                const t = points.map(p => p.t);
                const x = points.map(p => p.xm);
                const y = points.map(p => p.ym);
                const vx = diffCentral(t, x);
                const vy = diffCentral(t, y);
                const ax = diffCentral(t, vx);
                const ay = diffCentral(t, vy);
                renderTable(t, x, y, vx, vy, ax, ay);
                updateMainChart(t, x, y, vx, vy, ax, ay);
            }

            function updateMainChart(t, x, y, vx, vy, ax, ay) {
                let data = [], ylabel = '';

                // 表示モードに合わせてデータを決定
                switch (mode) {
                    case 'xt': data = x; ylabel = 'x [m]'; break;
                    case 'yt': data = y; ylabel = 'y [m]'; break;
                    case 'vxt': data = vx; ylabel = 'vx [m/s]'; break;
                    case 'vyt': data = vy; ylabel = 'vy [m/s]'; break;
                    case 'axt': data = ax; ylabel = 'ax [m/s²]'; break;
                    case 'ayt': data = ay; ylabel = 'ay [m/s²]'; break;
                }

                // ▼▼▼ 修正：データを {x:時間, y:値} の形式に変換して渡す ▼▼▼
                // データが存在する場合のみマッピング処理を行う
                if (t && t.length > 0 && data && data.length > 0) {
                    const scatterData = t.map((timeVal, i) => ({
                        x: timeVal,
                        y: data[i]
                    }));
                    ch.data.datasets[0].data = scatterData;
                } else {
                    ch.data.datasets[0].data = [];
                }

                // ラベル配列は使わないので空にする（リニア軸の場合は不要）
                ch.data.labels = [];

                // データセットのラベル更新
                ch.data.datasets[0].label = mode.toUpperCase();

                // Y軸ラベルの更新
                ch.options.scales.y.title.text = ylabel;

                // Y軸の範囲調整（以前のコードのまま）
                if (Array.isArray(data) && data.length) {
                    let dmin = Infinity, dmax = -Infinity;
                    for (const v of data) { if (Number.isFinite(v)) { dmin = Math.min(dmin, v); dmax = Math.max(dmax, v); } }
                    if (!Number.isFinite(dmin) || !Number.isFinite(dmax)) { dmin = -1; dmax = 1; }
                    let lo = Math.min(0, dmin), hi = Math.max(0, dmax);
                    if (Math.abs(hi - lo) < 1e-6) { const pad = (Math.abs(hi) || 1) * 0.5; lo -= pad; hi += pad; }
                    else { const pad = (hi - lo) * 0.05; lo -= pad; hi += pad; }
                    ch.options.scales.y.min = lo; ch.options.scales.y.max = hi;
                } else { ch.options.scales.y.min = -1; ch.options.scales.y.max = 1; }

                ch.update();

                // モード表示の更新
                const ml = document.getElementById('modeLabel');
                if (ml) ml.textContent = ({ xt: 'x-t', yt: 'y-t', vxt: 'vx-t', vyt: 'vy-t', axt: 'ax-t', ayt: 'ay-t' })[mode] || mode;
            }
            function diffCentral(t, y) {
                if (t.length < 2) return t.map(() => NaN);
                const n = t.length; const dy = new Array(n).fill(NaN);
                if (n > 1) { dy[0] = (y[1] - y[0]) / (t[1] - t[0]); dy[n - 1] = (y[n - 1] - y[n - 2]) / (t[n - 1] - t[n - 2]); }
                for (let i = 1; i < n - 1; i++) { const dt = t[i + 1] - t[i - 1]; if (Math.abs(dt) > 1e-9) dy[i] = (y[i + 1] - y[i - 1]) / dt; }
                return dy;
            }

            // --- Video Control (修正版) ---
            function stepFrame(dir) {
                const fps = clampFPS(+fpsInput.value);
                kFPS.textContent = fps.toFixed(2);
                const dt = 1.0 / Math.max(1, fps);

                // ★ 修正点: 境界問題を回避するための微小オフセット (1ms)
                // iPhone動画をWindowsで扱う際、30fpsジャストで加算すると
                // 浮動小数点誤差により「現在のコマ」から抜け出せない場合があるため。
                const epsilon = 0.001;

                video.pause(); playing = false; btnPlay.textContent = '再生/一時停止';

                // 進むときは +epsilon, 戻るときは -epsilon で確実に境界を越える
                let target = video.currentTime + (dir * dt) + (dir * epsilon);

                target = clamp(target, 0, (video.duration || 0));
                return seekTo(target);
            }

            function clamp(v, min = 0, max = 1) { return Math.min(max, Math.max(min, v)); }
            function clampFPS(v) { if (!isFinite(v) || v <= 0) return 30; return Math.min(240, Math.max(1, v)); }

            function seekTo(t) {
                return new Promise(res => {
                    const onSeeked = () => {
                        clearTimeout(timer);
                        drawFrame();
                        requestAnimationFrame(() => {
                            drawFrame();
                            res();
                        });
                    };

                    // ★重要：iPad Safariでも確実に拾えるよう once で登録
                    video.addEventListener('seeked', onSeeked, { once: true });

                    // ★保険：seeked が来ないケースに備える（300ms程度）
                    const timer = setTimeout(() => {
                        // それでも描画だけはして返す
                        drawFrame();
                        res();
                    }, 300);

                    video.currentTime = t;
                });
            }

            btnPrev.onclick = async () => { await stepFrame(-1); };
            btnNext.onclick = async () => { await stepFrame(+1); };

            btnPlay.onclick = () => { if (!playing) { video.play(); playing = true; btnPlay.textContent = '一時停止'; } else { video.pause(); playing = false; btnPlay.textContent = '再生/一時停止'; } };

            // 1m校正
            btnCalib.onclick = () => {
                calibMode = true; calibDragging = false; calibStart = calibEnd = null;
                btnCalib.disabled = true; scaleInfo.textContent = '1 m の両端をドラッグして指定';
            };

            // 軸の設定 → プロット開始
            btnAxis.onclick = () => {
                axisMode = true; axisActive = false;
                btnStartPlot.disabled = false;
                drawFrame();
            };
            btnStartPlot.onclick = () => {
                axisMode = false; axisActive = true;
                btnStartPlot.disabled = true;
                drawFrame();
            };

            btnUndo.onclick = async () => {
                if (points.length) {
                    points.pop();
                    kPoints.textContent = points.length;
                    recompute();
                    await stepFrame(-1);
                }
            };

            btnClear.onclick = () => {
                if (confirm('記録をすべて消去しますか？')) {
                    points = []; origin = null; calibMode = false; calibDragging = false; calibStart = calibEnd = null;
                    axisActive = false; axisMode = false;
                    btnAxis.disabled = true;
                    btnStartPlot.disabled = true;

                    kPoints.textContent = '0'; kTime.textContent = '0.000'; originInfo.textContent = '原点: 初期点';
                    scaleInfo.textContent = '未校正'; kScale.textContent = '—';
                    drawFrame(); recompute();
                }
            };

            // CSV
            btnCSV.onclick = () => {
                if (!points.length) return alert("データがありません");
                let csv = "t[s],x[m],y[m],vx[m/s],vy[m/s],ax[m/s^2],ay[m/s^2]\n";
                // 再計算用
                const t = points.map(p => p.t);
                const x = points.map(p => p.xm);
                const y = points.map(p => p.ym);
                const vx = diffCentral(t, x);
                const vy = diffCentral(t, y);
                const ax = diffCentral(t, vx);
                const ay = diffCentral(t, vy);

                for (let i = 0; i < points.length; i++) {
                    csv += `${t[i]},${x[i]},${y[i]},${vx[i]},${vy[i]},${ax[i]},${ay[i]}\n`;
                }
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'motion_data.csv'; a.click();
            };

            // Graph Image
            btnPNGCurrent.onclick = () => {
                const url = ch.toBase64Image();
                const a = document.createElement('a');
                a.href = url; a.download = 'chart.png'; a.click();
            };

            // Mode buttons
            modeButtons.forEach(btn => {
                btn.onclick = () => {
                    mode = btn.dataset.mode;
                    recompute();
                };
            });

            // ファイル読込
            file.addEventListener('change', async (e) => {
                if (!e.target.files || !e.target.files[0]) return;
                const f = e.target.files[0];
                await loadVideo(URL.createObjectURL(f));
            });

            btnDemo.onclick = async () => {
                try { await loadVideo(DEMO_URL); }
                catch (e) { alert("デモ動画の読み込みに失敗しました。"); }
            };

            async function loadVideo(url) {
                resetAll();
                video.src = url;
                video.playsInline = true;
                video.muted = true;
                video.load();
                await new Promise(res => video.addEventListener('loadedmetadata', res, { once: true }));
                guessFPS();
                resizeCanvasToVideo();
                drawFrame();
            }

            function resetAll() {
                points = []; origin = null; scalePxPerMeter = null; calibMode = false; calibDragging = false; calibStart = calibEnd = null;
                axisActive = false; axisMode = false;
                axis.theta = 0;
                btnAxis.disabled = true;
                btnStartPlot.disabled = true;

                kPoints.textContent = '0'; kTime.textContent = '0.000'; kScale.textContent = '—'; scaleInfo.textContent = '未校正'; originInfo.textContent = '原点: 初期点';
                ch.data.labels = []; ch.data.datasets[0].data = []; ch.update();
                recompute();
            }

            function guessFPS() {
                if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                    try {
                        let t0 = null, t1 = null;
                        const cb = (_, info) => {
                            if (!t0) { t0 = info.mediaTime; video.requestVideoFrameCallback(cb); }
                            else if (!t1) { t1 = info.mediaTime; const fps = 1 / Math.max(1e-6, (t1 - t0)); if (fps > 5 && fps < 240) { fpsInput.value = fps.toFixed(2); kFPS.textContent = fps.toFixed(2); } }
                        };
                        video.requestVideoFrameCallback(cb);
                    } catch (e) { }
                }
            }

            function renderTable(t, x, y, vx, vy, ax, ay) {
                const tb = document.getElementById('tableBody'); if (!tb) return;
                let html = '';
                for (let i = 0; i < points.length; i++) {
                    html += `<tr><td>${i}</td><td>${(t[i] ?? NaN).toFixed(3)}</td><td>${(x[i] ?? NaN).toFixed(4)}</td><td>${(y[i] ?? NaN).toFixed(4)}</td><td>${(vx[i] ?? NaN).toFixed(4)}</td><td>${(vy[i] ?? NaN).toFixed(4)}</td><td>${(ax[i] ?? NaN).toFixed(4)}</td><td>${(ay[i] ?? NaN).toFixed(4)}</td></tr>`;
                }
                tb.innerHTML = html;
            }

            // ▼▼▼ ここから追加：グラフと動画の連動機能 ▼▼▼

            const cursor = document.getElementById('time-cursor');
            const chartBox = document.getElementById('chartBox');
            let isDraggingGraph = false;
            let pendingSeek = null;
            let seekScheduled = false;

            video.addEventListener('timeupdate', () => {
                if (video.paused) updateCursorFromVideo();
            });

            function updateCursorFromVideo() {
                // ドラッグ中は更新しない（カクつき防止）
                if (isDraggingGraph) return;

                // データがない、またはChartの準備ができていない場合は非表示
                if (!points.length || !ch.scales.x) {
                    cursor.style.display = 'none';
                    return;
                }

                const currentTime = video.currentTime;
                const chartArea = ch.chartArea;

                // 時間をグラフ上のピクセル位置(X)に変換
                // Chart.jsの機能を使います
                const x = ch.scales.x.getPixelForValue(currentTime);

                // グラフの描画エリア（左右の軸の内側）に収まっているか判定
                if (x >= chartArea.left && x <= chartArea.right) {
                    cursor.style.display = 'block';
                    cursor.style.left = `${x}px`;
                    // 線の高さをグラフ描画エリアに合わせる（下の軸文字に被らないように調整）
                    cursor.style.top = `${chartArea.top}px`;
                    cursor.style.height = `${chartArea.bottom - chartArea.top}px`;
                } else {
                    cursor.style.display = 'none'; // 範囲外なら隠す
                }
            }

            // 2. グラフ上の操作で動画を動かす（ドラッグ＆クリック）
            chartBox.addEventListener('pointerdown', (e) => {
                // データがない場合は何もしない
                if (!points.length) return;

                isDraggingGraph = true;
                e.preventDefault(); // テキスト選択などを防止
                if (chartBox.setPointerCapture) chartBox.setPointerCapture(e.pointerId);
                syncVideoToGraphMouse(e);
            });

            window.addEventListener('pointermove', (e) => {
                if (isDraggingGraph) {
                    syncVideoToGraphMouse(e);
                }
            });

            window.addEventListener('pointerup', () => {
                if (isDraggingGraph) {
                    isDraggingGraph = false;
                    if (chartBox.releasePointerCapture && e?.pointerId != null) {
                        try { chartBox.releasePointerCapture(e.pointerId); } catch (_) { }
                    }
                    // ドラッグ終了時に、念のため正しい位置に線を同期
                    updateCursorFromVideo();
                }
            });

            // マウス位置から時間を計算して動画をシーク
            function syncVideoToGraphMouse(e) {
                // Chart.jsのスケール情報がない場合は中止
                if (!ch.scales.x) return;

                const rect = chartBox.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;

                // X座標(px)を時間(t)に逆変換
                let targetTime = ch.scales.x.getValueForPixel(mouseX);

                // 動画の範囲内に収める
                targetTime = Math.max(0, Math.min(targetTime, video.duration || 0));

                // 1. 縦線を即座に動かす（体感速度向上）
                cursor.style.display = 'block';
                cursor.style.left = `${mouseX}px`;
                const chartArea = ch.chartArea;
                if (chartArea) {
                    cursor.style.top = `${chartArea.top}px`;
                    cursor.style.height = `${chartArea.bottom - chartArea.top}px`;
                }

                // ★iPad Safari対策：seek連打を間引き（最新値のみ反映）
                pendingSeek = targetTime;
                if (!seekScheduled) {
                    seekScheduled = true;
                    requestAnimationFrame(() => {
                        seekScheduled = false;
                        if (pendingSeek != null) {
                            const t = pendingSeek;
                            pendingSeek = null;
                            seekTo(t);
                        }
                    });
                }
            }

            // ▼▼▼ ここから：スムーズな再生のための追加コード ▼▼▼

            // 再生中、常に画面とグラフを更新し続けるループ関数
            function renderLoop() {
                if (video.paused || video.ended) return; // 停止中はループ終了

                drawFrame();            // Canvas（動画と点）の描画
                updateCursorFromVideo(); // グラフの赤線の移動

                requestAnimationFrame(renderLoop); // 次のコマの描画を予約（ここが重要）
            }


            // ▼▼▼ 追加：コマ送りやスライダー操作の瞬間に画面を更新する ▼▼▼
            video.addEventListener('seeked', () => {
                // 動画が停止している時だけ、ここで手動更新する
                // (再生中は renderLoop が描画しているので、ここで描く必要はない)
                if (video.paused) {
                    drawFrame();            // 動画と点の描画
                    updateCursorFromVideo(); // グラフの赤線の移動
                }
            });

            // 動画が「再生」されたらループを開始
            video.addEventListener('play', () => {
                playing = true;
                btnPlay.textContent = '一時停止';
                renderLoop(); // ★ループ開始！
            });

            // 動画が「停止」したらボタンの表示を戻す
            video.addEventListener('pause', () => {
                playing = false;
                btnPlay.textContent = '再生/一時停止';
                // 停止時にも念のため一回描画して位置ズレを防ぐ
                drawFrame();
                updateCursorFromVideo();
            });

            // 再生ボタンの処理をシンプルにする（動画の機能を呼ぶだけにする）
            btnPlay.onclick = () => {
                if (video.paused) {
                    video.play();
                } else {
                    video.pause();
                }
            };


        })();
    </script>
</body>

</html>
