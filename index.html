<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>動画運動解析（ブラウザ/iOS対応・手動トラッキング）</title>
<link rel="icon" href="data:,">
<style>
  :root { --gap: 12px; --card: #111827; --ink: #e5e7eb; --muted:#9ca3af; --accent:#22c55e; --danger:#ef4444; --warn:#f59e0b;}
  html,body{height:100%}
  body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; background:#0b1220; color:var(--ink);}
  .wrap{max-width:1200px; margin:0 auto; padding:16px;}
  h1{font-size:clamp(18px,3vw,28px); margin:0 0 8px;}
  p.sub{color:var(--muted); margin:0 0 16px}
  .grid{display:grid; grid-template-columns: 1.15fr 1fr; gap:var(--gap)}
  .card{background:var(--card); border:1px solid #1f2937; border-radius:14px; padding:12px;}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .row > *{margin:4px 0}
  label{font-size:12px; color:var(--muted)}
  input[type="number"], input[type="text"], input[type="file"], select, button{background:#0f172a; color:var(--ink); border:1px solid #374151; border-radius:10px; padding:8px 10px; font-size:14px}
  button{cursor:pointer}
  button.primary{background:#0b2b17; border-color:#134e32}
  button.accent{background:#0d2918; border-color:#14532d; color:#a7f3d0}
  button.warn{background:#2b1f0b; border-color:#78350f; color:#fde68a}
  button.danger{background:#2b0b0b; border-color:#7f1d1d; color:#fecaca}
  button:disabled{opacity:.5; cursor:not-allowed}
  .pill{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; background:#0f172a; border:1px solid #374151; font-size:12px; color:var(--muted)}
  canvas{width:100%; height:auto; background:#000; border-radius:12px; touch-action:none}
  .mini{font-size:12px; color:var(--muted)}
  .charts{display:grid; grid-template-columns: 1fr 1fr; gap:var(--gap)}
  .charts canvas{background:#0a0f1c;}
  .kpi{display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:10px; margin:8px 0 0}
  .kpi .card{padding:10px}
  .kpi .val{font-weight:700; font-size:18px}
  .dot{width:10px; height:10px; border-radius:50%}
  .legend{display:flex; gap:10px; align-items:center; margin:6px 0 0}
  .hint{color:#a5b4fc}
  .sep{height:1px; background:#1f2937; margin:8px 0}
  details summary{cursor:pointer}
  .table-fixed thead th{position:sticky; top:0; background:#0f172a}
  table th, table td{border-bottom:1px solid #1f2937; padding:4px 6px; text-align:right}
  table th:first-child, table td:first-child{text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>動画運動解析アプリ</h1>
  <p class="sub"><br>・1 m 物体でスケール校正 → 1コマずつクリックで座標記録（最初の記録点を原点扱い） → グラフ自動更新 → 画像/CSV保存</p>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <label>動画を読み込む</label>
          <input id="file" type="file" accept="video/*" />
          <button id="btnDemo" class="warn" title="小さなデモ動画を読み込み">デモ</button>
        </div>
        <div class="pill" title="iOS向け設定: インライン再生・自動停止">
          <span>iOS最適化</span>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="btnPrev">◀︎ 1フレーム</button>
        <button id="btnNext">1フレーム ▶︎</button>
        <button id="btnPlay" class="primary">再生/一時停止</button>
        <div class="pill"><span>FPS</span> <input id="fps" type="number" step="0.01" value="30" style="width:78px"> <span class="mini">（自動取得が不安定な時は手入力）</span></div>
        <div class="pill"><label><input id="autoStep" type="checkbox" checked> クリック後に自動で1コマ進む</label></div>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="btnCalib" class="accent">1 m 校正（ドラッグ または 2点タップ）</button>
        <span id="scaleInfo" class="mini">未校正</span>
        <button id="btnSetOrigin" style="display:none">原点設定（任意）</button>
        <button id="btnOriginDrag" style="display:none">原点ドラッグ</button>
        <span id="originInfo" class="mini">原点: 初期点</span>
        <button id="btnUndo" class="warn">一つ戻す</button>
        <button id="btnClear" class="danger">全消去</button>
      </div>

      <div class="sep"></div>

      <canvas id="canvas" width="960" height="540"></canvas>
      <div class="mini hint">操作ヒント：<b>校正</b>を押した後、1 m の両端をドラッグ（または2点タップ）で指定 → 各コマでマーカー位置をタップ（記録後は自動で1コマ進む）。<br>原点は任意（最初の記録点を原点扱い）。</div>

      <video id="video" playsinline muted preload="metadata" style="display:none"></video>
    </div>

    <div class="card">
      <div class="kpi">
        <div class="card"><div class="mini">記録点数</div><div id="kPoints" class="val">0</div></div>
        <div class="card"><div class="mini">経過時間[s]</div><div id="kTime" class="val">0.000</div></div>
        <div class="card"><div class="mini">スケール[px/m]</div><div id="kScale" class="val">—</div></div>
        <div class="card"><div class="mini">FPS</div><div id="kFPS" class="val">30.00</div></div>
      </div>

      <div class="sep"></div>

      <div class="row">
        <button id="btnCSV" class="primary">CSVダウンロード</button>
        <button id="btnPNGCurrent" title="現在のグラフ画像">グラフ画像</button>
      </div>

      <details style="margin-top:8px"><summary>計算設定（微分法）</summary>
        <div class="row" style="margin-top:6px">
          <label>速度：中央差分</label>
          <label>加速度：中央差分</label>
          <label class="mini">端点は前進/後退差分</label>
        </div>
      </details>

      <div class="sep"></div>

      <div class="row" id="chartControls" style="margin-bottom:8px">
        <button class="modeBtn" data-mode="xt">x-t</button>
        <button class="modeBtn" data-mode="yt">y-t</button>
        <button class="modeBtn" data-mode="vxt">vx-t</button>
        <button class="modeBtn" data-mode="vyt">vy-t</button>
        <button class="modeBtn" data-mode="axt">ax-t</button>
        <button class="modeBtn" data-mode="ayt">ay-t</button>
        <span class="pill">現在: <span id="modeLabel">x-t</span></span>
      </div>
      <div id="rightPane" style="display:grid; grid-template-rows: 260px 1fr; gap:8px; height:420px">
        <div id="chartBox" style="height:260px; overflow:hidden">
          <canvas id="chart_main" style="width:100%; height:100%"></canvas>
        </div>
        <div class="card" style="overflow:auto;">
          <table id="dataTable" style="width:100%; border-collapse:collapse; font-size:12px">
            <thead>
              <tr>
                <th>#</th><th>t[s]</th><th>x[m]</th><th>y[m]</th><th>vx[m/s]</th><th>vy[m/s]</th><th>ax[m/s²]</th><th>ay[m/s²]</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
(() => {
  // DOM refs
  const file = document.getElementById('file');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnPlay = document.getElementById('btnPlay');
  const btnCalib = document.getElementById('btnCalib');
  const btnUndo = document.getElementById('btnUndo');
  const btnClear = document.getElementById('btnClear');
  const btnSetOrigin = document.getElementById('btnSetOrigin');
  const btnDemo = document.getElementById('btnDemo');
  const btnOriginDrag = document.getElementById('btnOriginDrag');
  const fpsInput = document.getElementById('fps');
  const autoStep = document.getElementById('autoStep');
  const scaleInfo = document.getElementById('scaleInfo');
  const originInfo = document.getElementById('originInfo');
  const kPoints = document.getElementById('kPoints');
  const kTime = document.getElementById('kTime');
  const kScale = document.getElementById('kScale');
  const kFPS = document.getElementById('kFPS');
  const btnCSV = document.getElementById('btnCSV');

  // State
  let points = []; // {t, xpx, ypx, xm, ym}
  let origin = null; // {xm, ym}
  let scalePxPerMeter = null; // pixels per meter
  let calibClicks = []; // [{x,y}]（タップ×2用）
  let setOriginMode = false;
  let calibMode = false;
  let playing = false;

  // 校正ドラッグ用
  let calibStart = null;     // {x, y}
  let calibEnd = null;       // {x, y}
  let calibDragging = false; // ドラッグ中フラグ

  // Chart (single)
  const ch = new Chart(document.getElementById('chart_main'), {
    type: 'line',
    data: { labels: [], datasets: [{ label: '', data: [], pointRadius:2, tension:0 }]},
    options: {
      animation:false,
      responsive:true,
      maintainAspectRatio:false,
      scales: {
        x: { title: { display:true, text:'t [s]', color:'#e5e7eb' },
             ticks: { color:'#e5e7eb' }, grid: { color:'#334155' } },
        y: { title: { display:true, text:'', color:'#e5e7eb' },
             ticks: { color:'#e5e7eb' }, grid: { color:'#334155' } }
      },
      plugins: { legend:{display:false} }
    }
  });
  let mode='xt';

  // Helpers
  const dpr = () => (window.devicePixelRatio || 1);
  function resizeCanvasToVideo() {
    const w = video.videoWidth || 960;
    const h = video.videoHeight || 540;
    const ratio = dpr();
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    ctx.setTransform(ratio,0,0,ratio,0,0);
    drawFrame();
  }

  function drawFrame() {
    const w = canvas.width / dpr();
    const h = canvas.height / dpr();
    ctx.clearRect(0,0,w,h);
    if (!isNaN(video.duration) && video.readyState >= 2) {
      try { ctx.drawImage(video, 0, 0, w, h); } catch(e) {}
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
    }

    // --- 校正オーバーレイ（ドラッグ／2点タップ両対応） ---
    if (calibMode) {
      let a = null, b = null;
      if (calibDragging && calibStart) { a = calibStart; b = (calibEnd || mousePos); }
      else if (calibClicks.length === 1) { a = calibClicks[0]; b = mousePos; }
      if (a && b) {
        ctx.strokeStyle = '#fde68a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();

        const d = Math.hypot(b.x - a.x, b.y - a.y);
        ctx.fillStyle = '#fde68a';
        ctx.font = '12px system-ui';
        ctx.fillText(`${d.toFixed(1)} px`, (a.x+b.x)/2 + 6, (a.y+b.y)/2 - 6);
      }
    }

    // トラックの軌跡
    if (points.length) {
      ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2; ctx.beginPath();
      ctx.moveTo(points[0].xpx, points[0].ypx);
      for (let i=1;i<points.length;i++){ ctx.lineTo(points[i].xpx, points[i].ypx); }
      ctx.stroke();
      for (let i=0;i<points.length;i++){
        ctx.fillStyle = '#22c55e';
        ctx.beginPath(); ctx.arc(points[i].xpx, points[i].ypx, 4, 0, Math.PI*2); ctx.fill();
      }
    }

    // クロスヘア
    if (mousePos){
      ctx.strokeStyle = '#9ca3afaa'; ctx.lineWidth = 1; ctx.beginPath();
      ctx.moveTo(mousePos.x-10, mousePos.y); ctx.lineTo(mousePos.x+10, mousePos.y);
      ctx.moveTo(mousePos.x, mousePos.y-10); ctx.lineTo(mousePos.x, mousePos.y+10);
      ctx.stroke();
    }
  }

  // Pointer（iPadの二重タップ防止：pointer系に統一）
  const rect = () => canvas.getBoundingClientRect();
  let mousePos = {x:0,y:0};

  function getXY(evt){
    const r = rect();
    const ratio = canvas.width / dpr() / r.width;
    const clientX = evt.clientX;
    const clientY = evt.clientY;
    return { x: (clientX - r.left) * ratio, y: (clientY - r.top) * ratio };
  }

  canvas.addEventListener('pointermove', e => {
    mousePos = getXY(e);
    if (calibMode && calibDragging) { calibEnd = getXY(e); }
    drawFrame();
  }, {passive:false});

  canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const p = getXY(e);

    if (calibMode) {
      // ドラッグ校正の開始
      if (!calibDragging && calibClicks.length === 0) {
        calibStart = p;
        calibEnd = p;
        calibDragging = true;
        drawFrame();
        return;
      }
      // 2点タップ方式にも対応
      if (calibClicks.length === 0) {
        calibClicks.push(p);
      } else if (calibClicks.length === 1) {
        calibClicks.push(p);
        finalizeCalibration(calibClicks[0], calibClicks[1]);
      }
      drawFrame();
      return;
    }

    // 原点設定モード（任意・現状UIでは非表示）
    if (setOriginMode){
      const xm = toMetersX(p.x);
      const ym = toMetersY(p.y);
      origin = {xm, ym};
      originInfo.textContent = `原点: (${origin.xm.toFixed(3)}, ${origin.ym.toFixed(3)}) m`;
      setOriginMode = false; btnSetOrigin.disabled = false;
      drawFrame();
      return;
    }

    // 通常の1点記録
    recordPoint(p.x, p.y, video.currentTime);
    if (autoStep.checked) stepFrame(+1);
  }, {passive:false});

  canvas.addEventListener('pointerup', e => {
    if (calibMode && calibDragging && calibStart) {
      calibEnd = getXY(e);
      finalizeCalibration(calibStart, calibEnd);
    }
  }, {passive:false});

  // 校正確定（共通：ドラッグ／タップ×2）
  function finalizeCalibration(a, b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dpx = Math.hypot(dx, dy);
    if (dpx > 0) {
      scalePxPerMeter = dpx / 1.0; // 1mのpx
      scaleInfo.textContent = `校正済: ${dpx.toFixed(1)} px = 1.000 m`;
      kScale.textContent = scalePxPerMeter.toFixed(2);
    }
    calibClicks = [];
    calibMode = false;
    calibDragging = false;
    calibStart = null;
    calibEnd = null;
    btnCalib.disabled = false;
    drawFrame();
  }

  function toMetersX(xpx){
    if (!scalePxPerMeter) return NaN;
    const xm = xpx / scalePxPerMeter;
    if (origin) return xm - origin.xm; // 原点補正
    if (points.length) {
      const originXm = points[0].xpx / scalePxPerMeter;
      return xm - originXm;
    }
    return xm;
  }
  function toMetersY(ypx){
    if (!scalePxPerMeter) return NaN;
    const ym = -ypx / scalePxPerMeter; // 上を正にする
    if (origin) return ym - origin.ym;
    if (points.length) {
      const originYm = -points[0].ypx / scalePxPerMeter;
      return ym - originYm;
    }
    return ym;
  }

  function recordPoint(xpx, ypx, t){
    if (scalePxPerMeter==null){ alert('先に「1 m 校正」を行ってください。'); return; }
    if (points.length === 0 && !origin) {
      const originXm = xpx / scalePxPerMeter;
      const originYm = -ypx / scalePxPerMeter;
      origin = { xm: originXm, ym: originYm };
      originInfo.textContent = `原点: 初期点`;
    }
    const xm = (xpx / scalePxPerMeter) - origin.xm;
    const ym = (-ypx / scalePxPerMeter) - origin.ym;
    points.push({t, xpx, ypx, xm, ym});
    points.sort((a,b) => a.t - b.t);
    kPoints.textContent = points.length;
    if (points.length > 1) {
      kTime.textContent = (points[points.length-1].t - points[0].t).toFixed(3);
    }
    recompute();
    drawFrame();
  }

  function recompute(){
    if (points.length === 0) {
      renderTable([],[],[],[],[],[],[]);
      updateMainChart([],[],[],[],[],[],[]);
      return;
    }
    const t = points.map(p=>p.t);
    const x = points.map(p=>p.xm);
    const y = points.map(p=>p.ym);
    const vx = diffCentral(t,x);
    const vy = diffCentral(t,y);
    const ax = diffCentral(t,vx);
    const ay = diffCentral(t,vy);
    renderTable(t,x,y,vx,vy,ax,ay);
    updateMainChart(t,x,y,vx,vy,ax,ay);
  }

  // 縦軸に必ず0を含める
  function updateMainChart(t,x,y,vx,vy,ax,ay){
    let data=[], ylabel='';
    switch(mode){
      case 'xt': data=x; ylabel='x [m]'; break;
      case 'yt': data=y; ylabel='y [m]'; break;
      case 'vxt': data=vx; ylabel='vx [m/s]'; break;
      case 'vyt': data=vy; ylabel='vy [m/s]'; break;
      case 'axt': data=ax; ylabel='ax [m/s²]'; break;
      case 'ayt': data=ay; ylabel='ay [m/s²]'; break;
    }
    ch.data.labels = t.map(s=>(+s).toFixed(3));
    ch.data.datasets[0].label = mode.toUpperCase();
    ch.options.scales.y.title.text = ylabel;
    ch.data.datasets[0].data = data;

    if (Array.isArray(data) && data.length){
      let dmin = Infinity, dmax = -Infinity;
      for (const v of data){ if (Number.isFinite(v)){ dmin = Math.min(dmin,v); dmax = Math.max(dmax,v); } }
      if (!Number.isFinite(dmin) || !Number.isFinite(dmax)) { dmin=-1; dmax=1; }
      let lo = Math.min(0, dmin);
      let hi = Math.max(0, dmax);
      if (hi === lo){
        const pad = (Math.abs(hi)||1)*0.5; lo -= pad; hi += pad;
      } else {
        const pad = (hi - lo) * 0.05; lo -= pad; hi += pad;
      }
      ch.options.scales.y.min = lo;
      ch.options.scales.y.max = hi;
    } else {
      ch.options.scales.y.min = -1;
      ch.options.scales.y.max = 1;
    }

    ch.update();
    const ml = document.getElementById('modeLabel');
    if(ml) ml.textContent = ({xt:'x-t',yt:'y-t',vxt:'vx-t',vyt:'vy-t',axt:'ax-t',ayt:'ay-t'})[mode] || mode;
  }

  function diffCentral(t, y){
    if (t.length<2) return t.map(()=>NaN);
    const n=t.length; const dy = new Array(n).fill(NaN);
    if (n > 1) {
      dy[0] = (y[1]-y[0])/(t[1]-t[0]);
      dy[n-1] = (y[n-1]-y[n-2])/(t[n-1]-t[n-2]);
    }
    for (let i=1;i<n-1;i++){
      const dt = t[i+1]-t[i-1];
      if (Math.abs(dt) > 1e-9) dy[i] = (y[i+1]-y[i-1]) / dt;
    }
    return dy;
  }

  // Video control
  function stepFrame(dir){
    const fps = clampFPS(+fpsInput.value);
    kFPS.textContent = fps.toFixed(2);
    const dt = 1.0/Math.max(1, fps);
    video.pause(); playing=false; btnPlay.textContent = '再生/一時停止';
    const target = clamp(video.currentTime + dir*dt, 0, (video.duration||0));
    seekTo(target);
  }
  function clamp(v,min=0,max=1){ return Math.min(max, Math.max(min, v)); }
  function clampFPS(v){ if (!isFinite(v) || v<=0) return 30; return Math.min(240, Math.max(1, v)); }

  function seekTo(t){
    return new Promise(res=>{
      const on = ()=>{ video.removeEventListener('seeked', on); drawFrame(); res(); };
      video.addEventListener('seeked', on, {once:true});
      video.currentTime = t;
    });
  }

  btnPrev.onclick = ()=> stepFrame(-1);
  btnNext.onclick = ()=> stepFrame(+1);

  btnPlay.onclick = ()=>{
    if (!playing){ video.play(); playing=true; btnPlay.textContent='一時停止'; }
    else { video.pause(); playing=false; btnPlay.textContent='再生/一時停止'; }
  };

  btnCalib.onclick = ()=>{
    calibMode = true;
    calibClicks = [];       // タップ×2用
    calibDragging = false;  // ドラッグは pointerdown で開始
    calibStart = null;
    calibEnd = null;
    btnCalib.disabled = true;
    scaleInfo.textContent='1 m の両端を指定（ドラッグ または 2点タップ）';
  };

  btnSetOrigin.onclick = ()=>{ /* 任意原点UIを使う場合に有効化 */ }; btnSetOrigin.disabled = true;

  btnUndo.onclick = ()=>{
    if(points.length){
      points.pop();
      kPoints.textContent = points.length;
      recompute(); drawFrame();
    }
  };

  btnClear.onclick = ()=>{
    if(confirm('記録をすべて消去しますか？')){
      points=[]; origin=null; calibClicks=[]; setOriginMode=false; calibMode=false;
      calibDragging=false; calibStart=null; calibEnd=null;
      kPoints.textContent='0'; kTime.textContent='0.000'; originInfo.textContent='原点: 初期点';
      scaleInfo.textContent='未校正'; kScale.textContent='—';
      drawFrame(); recompute();
    }
  };

  // File loading
  file.addEventListener('change', async (e)=>{
    if (!e.target.files || !e.target.files[0]) return;
    const f = e.target.files[0];
    await loadVideo(URL.createObjectURL(f));
  });

  btnDemo.onclick = async ()=>{
    const DEMO_MP4_BASE64 = "";
    if (!DEMO_MP4_BASE64) { alert("デモ動画データが設定されていません。"); return; }
    const demoUrl = "data:video/mp4;base64," + DEMO_MP4_BASE64;
    await loadVideo(demoUrl);
  };

  async function loadVideo(url){
    resetAll();
    video.src = url;
    video.playsInline = true; // iOS
    video.muted = true;
    await video.load();
    await new Promise(res=> video.addEventListener('loadedmetadata', res, {once:true}));
    guessFPS();
    resizeCanvasToVideo();
    drawFrame();
  }

  function resetAll(){
    points=[]; origin=null; scalePxPerMeter=null; calibClicks=[]; calibMode=false; setOriginMode=false;
    calibDragging=false; calibStart=null; calibEnd=null;
    kPoints.textContent='0'; kTime.textContent='0.000'; kScale.textContent='—'; scaleInfo.textContent='未校正'; originInfo.textContent='原点: 初期点';
    ch.data.labels=[]; ch.data.datasets[0].data=[]; ch.update();
    recompute();
  }

  function guessFPS(){
    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype){
      try {
        let t0=null, t1=null;
        const cb = (_, info)=>{
          if (!t0){ t0 = info.mediaTime; video.requestVideoFrameCallback(cb); }
          else if (!t1){ t1 = info.mediaTime; const fps = 1/Math.max(1e-6, (t1-t0)); if (fps>5 && fps<240){ fpsInput.value = fps.toFixed(2); kFPS.textContent=fps.toFixed(2);} }
        };
        video.requestVideoFrameCallback(cb);
      } catch(e){}
    }
  }

  function renderTable(t,x,y,vx,vy,ax,ay){
    const tb = document.getElementById('tableBody'); if(!tb) return;
    let html='';
    for(let i=0;i<points.length;i++){
      html += `<tr><td>${i}</td><td>${(t[i]??NaN).toFixed(3)}</td><td>${(x[i]??NaN).toFixed(4)}</td><td>${(y[i]??NaN).toFixed(4)}</td><td>${(vx[i]??NaN).toFixed(4)}</td><td>${(vy[i]??NaN).toFixed(4)}</td><td>${(ax[i]??NaN).toFixed(4)}</td><td>${(ay[i]??NaN).toFixed(4)}</td></tr>`;
    }
    tb.innerHTML = html;
  }

  // CSV & PNG
  function download(name, blob){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name; a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  }

  btnCSV.onclick = ()=>{
    if (points.length === 0) { alert("記録されたデータがありません。"); return; }
    const t = points.map(p=>p.t);
    const x = points.map(p=>p.xm);
    const y = points.map(p=>p.ym);
    const vx = diffCentral(t,x);
    const vy = diffCentral(t,y);
    const ax = diffCentral(t,vx);
    const ay = diffCentral(t,vy);
    const header = ['frame','t_s','x_px','y_px','x_m','y_m','vx_m_s','vy_m_s','ax_m_s2','ay_m_s2'];
    const rows = [header.join(',')];
    for (let i=0;i<points.length;i++){
      const row = [i, t[i]?.toFixed(6), points[i].xpx.toFixed(2), points[i].ypx.toFixed(2), x[i]?.toFixed(6), y[i]?.toFixed(6), (vx[i]??NaN).toFixed(6), (vy[i]??NaN).toFixed(6), (ax[i]??NaN).toFixed(6), (ay[i]??NaN).toFixed(6)];
      rows.push(row.join(',')); // ← 1行はカンマ区切り
    }
    const csv = rows.join('\n'); // ← 行ごとに改行
    download('motion_data.csv', new Blob([csv], {type:'text/csv'}));
  };

  const btnPNGCurrent = document.getElementById('btnPNGCurrent');
  if(btnPNGCurrent){
    btnPNGCurrent.onclick = ()=>{
      const url = ch.toBase64Image();
      fetch(url).then(res=>res.blob()).then(b=> download(`graph_${mode}.png`, b));
    };
  }

  // グラフモード切り替え
  document.querySelectorAll('.modeBtn').forEach(btn => {
    btn.addEventListener('click', () => { mode = btn.dataset.mode; recompute(); });
  });

  // Rendering loop while playing
  function raf(){ if (playing) drawFrame(); requestAnimationFrame(raf); }
  raf();

  // Redraw on timeupdate & resize
  video.addEventListener('timeupdate', drawFrame);
  window.addEventListener('resize', ()=>{ if (video.videoWidth) resizeCanvasToVideo(); });
})();
</script>
</body>
</html>
